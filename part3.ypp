%{
    #include "part3_helpers.hpp"

	using namespace std;
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>

	extern char* yytext;
	extern int yylineno;
	extern "C" int yylex();
	extern void yylex_destroy();

	void printOperationalError (string err);
	void printSemanticError(string err);
	void yyerror(const char* c);

	%}

    %token tk_id
    %token tk_integernum tk_realnum
	%token tk_str
    %token tk_ellipsis
    %token tk_int tk_float
	%token tk_void tk_write tk_read 
    %token tk_while tk_do tk_return
    %token tk_va_arg

    %left tk_relop tk_addop tk_mulop
	%right tk_assign tk_not
	%right tk_if tk_then tk_else
    
	%left '(' ')' '{' '}' ':' ';'
    %left tk_or tk_and

	%%

	PROGRAM : FDEFS {
		// backpatch all the holes created by JLINK	
		for(map<string, Function>::iterator it = functionTable.begin();
			it != functionTable.end(); it++) {
			buffer->backpatch(it->second.callingLines, 
				it->second.startLineImplementation);
		}
	} ;

	FDEFS : FDEFS FUNC_DEF_API BLK M { // function definition
		// check if function is already defined
		if(functionTable[$2.name].isDefined != false) {
			printSemanticError("redefinition of function '" + $2.name + "'");
		}
		else { // save that a function with this name has been defined
			functionTable[$2.name].isDefined = true; 
		}
		buffer->emit("RETRN");

		// set globals 
		curScopeIntRegsNum = 3;
		curScopeFloatRegsNum = 3;
		curScopeOffset = 0;
		symbolTable.clear(); // ???
		$2.paramTypes.clear();
	}
	| FDEFS FUNC_DEC_API { // function declaration
		// if not defined yet, assume in another file
		if (functionTable[$2.name].isDefined != true) {
			functionTable[$2.name].startLineImplementation = -1;
		}
		symbolTable.clear(); // ???
	}
	| /* e */ {
    } ;

	FUNC_DEC_API : TYPE tk_id '(' ')' ';' {
			}
            | TYPE tk_id '(' M FUNC_ARGLIST ')' ';' {
			}
            | TYPE tk_id '(' M FUNC_ARGLIST ',' tk_ellipsis ')' ';' {
			} ;
    
    FUNC_DEF_API : TYPE tk_id '(' ')' {
			}
            | TYPE tk_id '(' M FUNC_ARGLIST ')' {
			}
            | TYPE tk_id '(' M FUNC_ARGLIST ',' tk_ellipsis ')' {
			} ;

	FUNC_ARGLIST : FUNC_ARGLIST ',' DCL {
				// insert function params to the global list in the reverse order
				for(int i=tmpParamInsertOrder.size()-1; i>=0; i--) {
					string paramName = tmpParamInsertOrder[i];
					curParamInsertOrder.push_back(paramName);
				}
				tmpParamInsertOrder.clear();
			}
			| DCL {
				for(int i=tmpParamInsertOrder.size()-1; i>=0; i--) {
					string paramName = tmpParamInsertOrder[i];
					curParamInsertOrder.push_back(paramName);
				}
				tmpParamInsertOrder.clear();
			} ;


	BLK :   '{' BLK_OPEN STLIST M BLK_CLOSE '}' {
		buffer->backpatch($3.nextList, $4.quad);
	} ;

	BLK_OPEN : {
		// open new block
		// buffer->emit("block start");
		curBlockDepth++;
	}
	;

	BLK_CLOSE : {
		// buffer->emit("block end");
		// delete vars in current scope when leaving it
		for(std::map<string, Symbol>::iterator it = symbolTable.begin(); it != symbolTable.end(); ++it){
			if (it->second.depth == curBlockDepth) {
				it->second.type.erase(curBlockDepth);
				it->second.offset.erase(curBlockDepth);
				it->second.depth--;
			}
		}
		
		// close the block
		curBlockDepth--;
	}

	DCL : tk_id ':' TYPE {
			if ($3.type == void_t) {
				printSemanticError("variables can't be of type void");
			}
			// check that this id does not colide with currrent function parameters
			if (find(curParamInsertOrder.begin(), curParamInsertOrder.end(),
				$1.name) != curParamInsertOrder.end()) {
				printSemanticError("redefinition of parameter '" + $1.name + "'");
			}

			prevScopeOffset = curScopeOffset;
			$$.name = $1.name;
			$$.type = $3.type;
			$$.offset = curScopeOffset;

			if( symbolTable.find($1.name) == symbolTable.end()) { 
				// symbol not defined yet
				Symbol s;
				s.depth = curBlockDepth;
				s.type[s.depth] = $3.type;

				s.offset[curBlockDepth] = curScopeOffset;
				curScopeOffset += 4;

				// save to symbol table
				symbolTable.insert(std::pair<string, Symbol>($1.name, s));
				// save to list for function calls
				tmpParamInsertOrder.push_back($1.name);
			} else { // symbol already defined somewhere
				// symbol already defined in same block
				if(symbolTable[$1.name].type.size() == curBlockDepth) {
					printSemanticError("redeclaration of identifier '" + $1.name + "'");
				}
				// add id to current block depth
				symbolTable[$1.name].depth = curBlockDepth;
				symbolTable[$1.name].type[curBlockDepth] = $3.type;
				symbolTable[$1.name].offset[curBlockDepth] = curScopeOffset;
				curScopeOffset += 4;
			}
		}
		| tk_id ',' DCL {
			if ($3.type == void_t) {
				printSemanticError("variables can't be of type void");
			}
			// check that this id does not colide with currrent function parameters
			if (find(curParamInsertOrder.begin(), curParamInsertOrder.end(),
				$1.name) != curParamInsertOrder.end()) {
				printSemanticError("redefinition of parameter '" + $1.name + "'");
			}
			// check in tmp also because its not first param
			if (find(tmpParamInsertOrder.begin(), tmpParamInsertOrder.end(),
				$1.name) != tmpParamInsertOrder.end()) {
				printSemanticError("redefinition of parameter '" + $1.name + "'");
			}

			// prevScopeOffset = curScopeOffset;
			$$.name = $1.name;
			$$.type = $3.type;
			// $$.offset = curScopeOffset;

			if(symbolTable.find($1.name) == symbolTable.end()) { 
				// symbol not defined yet
				Symbol s;
				s.depth = curBlockDepth;
				s.type[s.depth] = $3.type;

				s.offset[curBlockDepth] = curScopeOffset;
				curScopeOffset += 4;

				// save to symbol table
				symbolTable.insert(std::pair<string, Symbol>($1.name, s));
				// save to list for function calls
				tmpParamInsertOrder.push_back($1.name);
			} else { // symbol already defined somewhere
				// symbol already defined in same block
				if(symbolTable[$1.name].type.size() == curBlockDepth) {
					printSemanticError("redeclaration of identifier '" + $1.name + "'");
				}
				// add id to current block depth
				symbolTable[$1.name].depth = curBlockDepth;
				symbolTable[$1.name].type[curBlockDepth] = $3.type;
				symbolTable[$1.name].offset[curBlockDepth] = curScopeOffset;
				curScopeOffset += 4;
			}
		} ;

	TYPE :  tk_int {
				$$.type = int_
			}
            | tk_float {
				$$.type = float_
			}
            | tk_void {
				$$.type = void_t
			} ;

	STLIST :STLIST STMT { }
			| /* e */ { } ;

	STMT :  DCL ';' {
				// bring stack pointer up based on old offset
				tmpParamInsertOrder.clear();
				curParamInsertOrder.clear();
				int byteOffset = curScopeOffset - prevScopeOffset;
				buffer->emit("ADD2I I2 I2 " + intToString(byteOffset));
			}
			| ASSN { }
			| EXP ';' {
				if ($1.type != void_t) { // check if needed !!!
					printSemanticError("expression has incompatible type");
				}
			}
			| CNTRL M {
				// backpatch the nextlist of last ctrl block
				buffer->backpatch($1.nextList, $2.quad);
			}
			| READ { }
			| WRITE { } 
			| RETURN { }
			| BLK { } ;

	RETURN : tk_return EXP ';' {
		if (curRetType != $2.type or curRetType == void_t) {
			printSemanticError("wrong return type given");
		}
		$$.RegNum = $2.RegNum;
		buffer->emit("STORI I" + intToString($$.RegNum) + " I1 -4");
		buffer->emit("RETRN");
	}
	| tk_return ';' {
		if (curRetType != void_t) {
			printSemanticError("return value is not void but nothing is given");
		}
		// set I0 to return address
		// buffer->emit("LOADI I0 I2 4"); dont know if needed
		buffer->emit("RETRN");
	} ;

	WRITE : tk_write '(' EXP ')' ';' {
		if ($3.type == int_) { // ########### not sure works
			buffer->emit("PRNTI I" + intToString($3.RegNum));
		} else if ($3.type == float_) {
			buffer->emit("PRNTF F" + intToString($3.RegNum));
		}
			}
			| tk_write '(' tk_str ')' ';' {
				cout << $3.name << endl;
				for (unsigned int i = 0 ; i < $3.name.length() ; i++) {
				char c = $3.name[i];
				if (c == '\\') {
					if ($3.name[i+1] == 'n') {
						c = '\n';
						i++;
					}
					else if ($3.name[i+1] == 't') {
						c = '\t';
						i++;
					} else if ($3.name[i+1] == '"') {
						c = '"';
						i++;
					}
				}
				int val = static_cast<int>(c);
				buffer->emit("PRNTC " + intToString(val));
		}
			} ;

	READ :  tk_read '(' LVAL ')' ';'	{
			} ;


	ASSN :  LVAL tk_assign EXP ';' {
			} ;

	LVAL :  tk_id { // needs to be done still
		// check if variable exists
		if (symbolTable.find($1.name) == symbolTable.end()) {
			printSemanticError("use of undeclared identifier '" + $1.name + "'");
		}
		int depth = symbolTable[$1.name].depth;
		$$.type = symbolTable[$1.name].type[depth];
		
		if ($$.type == void_t) {
			printSemanticError("variable '" + $1.name + "' has incompatible type (void)");
		}

		// Allocate a register for the memory offset calulation
		// dont know why this is here ********
		// $$.RegNum = curScopeRegsNum++; 
		$$.offset = symbolTable[$1.name].offset[depth];
		buffer->emit("ADD2I I" + intToString($$.RegNum) + " I1 " + intToString($$.offset));
	} ;

	CNTRL : tk_if BEXP tk_then M STMT tk_else N M STMT {
				buffer->backpatch($2.trueList, $4.quad);
				buffer->backpatch($2.falseList, $8.quad);
				$$.nextList = merge<int>($5.nextList, $7.nextList);
				$$.nextList = merge<int>($$.nextList, $9.nextList);
				$5.nextList.clear();
				$9.nextList.clear();
				$7.nextList.clear();
			}
			| tk_if BEXP tk_then M STMT {
				buffer->backpatch($2.trueList, $4.quad);
				$$.nextList = merge<int>($2.falseList, $5.nextList);
				$2.falseList.clear();
				$5.nextList.clear();
			}
			| tk_while M BEXP tk_do M STMT {
				buffer->backpatch($3.trueList, $5.quad);
				buffer->backpatch($6.nextList, $2.quad);
				$$.nextList = $3.falseList;
				// UJUMP back to while BEXP
				// After backpatch the addressed would be filled
				buffer->emit("UJUMP " + intToString($2.quad));
			} ;

	BEXP :  BEXP tk_or M BEXP {
				buffer->backpatch($1.falseList, $3.quad);
				$$.falseList = $4.falseList;
				$$.trueList = merge<int>($1.trueList, $4.trueList);
				$1.trueList.clear();
				$4.trueList.clear();
			}
			| BEXP tk_and M BEXP {
				buffer->backpatch($1.trueList, $3.quad);
				$$.trueList = $4.trueList;
				$$.falseList = merge<int>($1.falseList, $4.falseList);
				$1.falseList.clear();
				$4.falseList.clear();
			}
			| tk_not BEXP {
				$$.trueList = $2.falseList;
				$$.falseList = $2.trueList;
			}
			| EXP tk_relop EXP {
			}
			| '(' BEXP ')' {
				$$.trueList = $2.trueList;
				$$.falseList = $2.falseList;
            } ;


	EXP : EXP tk_addop EXP {
			if ($1.type != $3.type) {
				printSemanticError("ADD ops require same type arguments");
			} else if ($1.type == void_t) {
				printSemanticError("can't perform arithmatic on void_t");
			}

			int leftReg = $1.RegNum;
			int rightReg = $3.RegNum;
			string type = ($1.type == float_) ? "F" : "I";
			
			if ($2.name == "+") { // ADD
			buffer->emit("ADD2" + type + " " + type + intToString($$.RegNum) + " " + type + 
							intToString(leftReg) + " " + type + intToString(rightReg));
			} else { // SUB
			buffer->emit("SUBT" + type + " " + type + intToString($$.RegNum) + " " + type + 
							intToString(leftReg) + " " + type + intToString(rightReg));
			}
		}
		| EXP tk_mulop EXP {
			if ($1.type != $3.type) {
				printSemanticError("MUL ops require same type arguments");
			} else if ($1.type == void_t) {
				printSemanticError("can't perform arithmatic on void_t");
			}

			int leftReg = $1.RegNum;
			int rightReg = $3.RegNum;
			string type = ($1.type == float_) ? "F" : "I";
			
			if ($2.name == "*") { // MUL
			buffer->emit("MULT" + type + " " + type + intToString($$.RegNum) + " " + type + 
							intToString(leftReg) + " " + type + intToString(rightReg));
			} else { // DEV
			buffer->emit("DIVD" + type + " " + type + intToString($$.RegNum) + " " + type + 
							intToString(leftReg) + " " + type + intToString(rightReg));
			}
			
		}
		| '(' EXP ')' {
			$$ = $2;
		}
		| '(' TYPE ')' EXP {
			if ($2.type != void_t && $4.type == void_t) {
				printSemanticError("can't cast void expressions");
			}

			if ($2.type == $4.type) {
				$$ = $4;
			}

			// float to int
			if ($2.type == int_ && $4.type == float_) {
				$$.RegNum = curScopeIntRegsNum++;
				$$.type = $2.type;
				$$.offset = $4.offset;
				buffer->emit("CFTOI I" + intToString($$.RegNum) + " F" + intToString($4.RegNum));
			}
			// int to float
			if ($2.type == float_ && $4.type == int_) {
				$$.RegNum = curScopeFloatRegsNum++;
				$$.type = $2.type;
				$$.offset = $4.offset;
				buffer->emit("CFTOI F" + intToString($$.RegNum) + " I" + intToString($4.RegNum));
			}
		}
		| tk_id { // check here again
			// Check that variable is declared
			if (symbolTable.find($1.name) == symbolTable.end()) {
				printSemanticError("use of undeclared identifier '" + $1.name + "'");
			}
			int depth = symbolTable[$1.name].depth;
			$$.type = symbolTable[$1.name].type[depth];
			string type;
			if ($$.type == int_) {
				type = "I";
				$$.RegNum = curScopeIntRegsNum++;
			} else { // float
				type = "F";
				$$.RegNum = curScopeFloatRegsNum++;
				// make float frame pointer
				buffer->emit("CITOF F1 I1");
			}
				
			$$.offset = symbolTable[$1.name].offset[depth];
		
			buffer->emit("LOAD" + type + " " + type + intToString($$.RegNum) + 
						 " " + type + "1 " + intToString($$.offset));
		}
		| NUM {
			$$.RegNum = $1.RegNum;
			$$.type = $1.type;
		}
		| CALL {
			$$.RegNum = $1.RegNum;
			$$.type = $1.type;
		}
        | VA_MATERIALISE { // not done yet
        } ;

    NUM : tk_integernum {
		cout << "number: " << $1.name << endl;
		$$.type = int_;
		$$.RegNum = curScopeIntRegsNum++;
		$$.name = $1.name;
		buffer->emit("COPYI I" + intToString($$.RegNum) + " " + $1.name);
	}
    | tk_realnum {
		cout << "float number: " << $1.name << endl;
		$$.type = float_;
		$$.RegNum = curScopeFloatRegsNum++;
		$$.name = $1.name;
		buffer->emit("COPYF F" + intToString($$.RegNum) + " " + $1.name);
	} ;

	CALL : tk_id '(' CALL_ARGS ')' {
		string func_name = $1.name;
		
		// function wasn't declared
		if(functionTable.find(func_name) == functionTable.end()) {
			printSemanticError("use of unknown function '" + func_name + "'");
		}

		Function* cur_func = &functionTable[func_name];
		// check that number of args matches definition
		if (cur_func->paramTypes.size() != $3.paramTypes.size()) {
			printSemanticError("incorrect number of arguments for function '" + func_name + "'");
		}

		// check that argument types match
		for (int i = 0; i < cur_func->paramTypes.size(); i++) {
			if (cur_func->paramTypes[i] != $3.paramTypes[i]) {
				printSemanticError("incompatible argument types in function '" + func_name + "'");
			}
		}

		// save function registers to memory
		int offset = 0;

		// for (int i = 0; i < curScopeIntRegsNum; ++i) {
		// 	buffer->emit("STI32 I" + intToString(i) + " I2 " + intToString(offset));
		// 	offset += 4;
		// }
		// for (int i = 0; i < curScopeFloatRegsNum; ++i) {
		// 	buffer->emit("STI32 I" + intToString(i) + " I2 " + intToString(offset));
		// 	offset += 4;
		// }

		// ############################################################

		// 4 bytes for return value
		offset += 4;
	} ;

    VA_MATERIALISE : tk_va_arg '(' TYPE ',' EXP ')' {
		// not done yet
	} ;

	CALL_ARGS : CALL_ARGLIST {
		$$.paramTypes = $1.paramTypes;	
		$$.paramRegs = $1.paramRegs;
		$1.paramTypes.clear();
		$1.paramRegs.clear();
	}
	| /* e */ {
	} ;


	CALL_ARGLIST : CALL_ARGLIST ',' EXP {
				$$.paramRegs = $1.paramRegs;
				$$.paramTypes = $1.paramTypes;
				$$.paramRegs.push_back($3.RegNum);
				$$.paramTypes.push_back($3.type);
				$1.paramTypes.clear();
				$1.paramRegs.clear();
			}
			|  EXP {
				$$.paramTypes.push_back($1.type);
				$$.paramRegs.push_back($1.RegNum);
			} ;

	// markers
	M : {
		$$.quad = buffer->nextQuad();
	}
	;
 
	N : {
		$$.nextList.push_back(buffer->nextQuad());
		buffer->emit("UJUMP ");
	}
	;
	%%



int main(int argc, char* argv[])
{
	cout << "\nstart compiling" << endl;
	if (argc != 2) {
		printOperationalError("invalid number of arguments");
	}

	string input_file = argv[1];
	size_t last_dot = input_file.find_last_of(".");
    if (input_file.substr(last_dot) != ".cmm") {
		printOperationalError("invalid file type. expecting '.cmm' extension");
	}

	extern FILE *yyin;
	yyin = fopen(argv[1], "r");
	if (yyin == NULL) {
		printOperationalError("cannot open input file");
	}

	Buffer headerBuffer;
	buffer = &headerBuffer;

    yyparse();

	// add header data
	headerBuffer.frontEmit("</header>");
	string imp_funcs = "<implemented>";
	string un_imp_funcs = "<unimplemented>";

	for(map<string, Function>::iterator it = functionTable.begin(); it != functionTable.end(); it++) {
		if (it->second.isDefined > 0) {
			imp_funcs += " " + it->first + "," 
					  + intToString(it->second.startLineImplementation);
		}
		else {
			un_imp_funcs += " " + it->first;
			for (int i = 0; i < it->second.callingLines.size(); i++) {
				un_imp_funcs += "," + 
							 intToString(it->second.callingLines[i]);
			}
		}
	}

	headerBuffer.frontEmit(imp_funcs);
	headerBuffer.frontEmit(un_imp_funcs);
	headerBuffer.frontEmit("<header>");

	ofstream output_rsk;
	string outputName = input_file.substr(0, last_dot) + ".rsk";
	// need both / and \ for linux/windows
	size_t last_name_in_path = outputName.find_last_of("/\\");
	outputName = outputName.substr(last_name_in_path+1);

	output_rsk.open(outputName.c_str());
	
	// the buffer contains the code gen already
	output_rsk << headerBuffer.printBuffer();
	output_rsk.close();

	yylex_destroy();
	cout << "stop compiling" << endl;
	return 0;
}

void printOperationalError (string err) {
	cerr << "Operational error: " << err << endl;
	exit(OPERATIONAL_ERROR);
}

void printSemanticError (string err) {
	cerr << "Semantic error: " << err << " in line number " << yylineno << endl;
	exit(SEMANTIC_ERROR);
}

void yyerror(char const* s) {
	cerr << "Syntax error: '" << yytext << "' in line number " << yylineno << endl;
	exit(SYNTAX_ERROR);
}